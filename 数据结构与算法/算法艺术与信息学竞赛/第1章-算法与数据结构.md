算法与数据结构是信息学竞赛最核心的部分，也是选手必备的基础知识。“数据结构+算法=程序设计”。这些知识不仅很重要，而且是学习其他内容的基础。



# 本章内容简介

本章从理论分析和实际应用两个方面阐述了算法与数据结构的基本知识。由于同类书籍对相关理论做了较为详尽的论述，本章把终点放在了实例分析上，因为它们可以帮助读者更为深刻地理解算法与数据结构的精髓。

1.1 节概括地叙述了算法、数据结构以及计算理论的一些简单概念，目的是让读者从宏观上对第1章的基础做一定的了解。

1.2 节从实例出发，概括地介绍了一些基本算法，包括枚举、贪心、递归、递推法等。本节的重点是让读者领会到常用的算法思想，因此所选的部分例题有相当的难度，读者需反复体会才能明白其中的道理。本节还有一些小专题，供读者选学。

1.3 节介绍基本数据结构，包括线性表、队列、栈、数、二叉树以及图的遍历与拓扑排序。和1.2节不同的是，本节的系统性比较强，为了突出趣味性和实用性，本节选用了一些有趣的故事引入这些内容，从而增加读者的感性认知。建议读者阅读专门的数据结构教材来获得系统的理论知识，打好基础。

1.4 节介绍一些实用数据结构，包括哈希表、二叉搜索树、Trie结构、线段树、堆、并查集等。本节的难度较大，而且实用性比较强，1.5和1.6节将广泛使用这里介绍的知识。

1.5 节介绍动态规划方法和一些经典动态规划问题，并结合一些例子讲述常见的建模技巧。

1.6 节介绍搜索算法。本节内容包括盲目搜索、启发式搜索、博弈算法和搜索的优化问题。本节的部分理论知识和例题比较难懂，建议读者多写程序来实现题解中提到的一些细节。

在大多数小节的后面，作者从近年来国内外竞赛中出现的基本算法与数据结构的中精选出一些问题以检验读者的学习效果。部分题目具有相当的难度，读者可以反复思考。本书主页附有部分练习的提示。



# 1.1 编程的灵魂-数据结构+算法=程序

本节介绍数据结构、算法的基本概念和复杂度分析的基本方法。本节的理论性比较强且部分内容和一些有一定基础的读者的“经验”有些违背。这些内容比较抽象，部分内容（如并行计算机、PS完全问题等）主要知识开阔读者的眼界。本节的重点是渐进时间复杂度的计算和化简，而难点是各个相关概念的正确理解和对计算机解题能力的整体认知。

本节不难学，建议读者同时另外阅读一本介绍计算复杂性的入门书籍，和本书结合起来看。阅读本书之前，读者需要熟练掌握一门程序设计语言，推荐使用C/C++或者java。但同时需要了解一些Pascal，如果不熟悉这些语言，阅读本书的效果则将会大打折扣。

首先需要弄清楚：什么是算法？什么是数据结构？为什么要学它们？简单地说，**算法（algorithm）** 就是解决问题的方法或者过程。如果把问题看成是函数，name算法就能把输入转化为输出；**数据结构**（data structure）是数据的计算机表示和相应的一组操作。这二者是最基本的，但对于初学者来说，最熟悉的名词并不是它们，而是**程序（Program）**算法和数据结构的具体实现。这三者的关系是本节的标题中已经指出了：“数据结构+算法=程序”。

本章在介绍算法时强调：

1. **算法思想**：深刻地理解这些算法设计思想将有助于开阔读者的思维。

2. **算法分析**：从时空性能、适用范围等对介绍的算法进行分析，增强读者对这些内容的理性认识，学会定性、定量地分析算法和进行比较。

需要说明的是，我们强调的是算法设计和分析，而不是对问题本身的分析。对问题本身性质的分析只是粗略地提一下， 作为算法设计的指导，而不作为重点学习和研究的内容。不过，一些重要的结果和方法，如NP完全理论和判定数模型，由于它们容易理解且用处很大，我们仍会花一些篇幅进行讲述。

**时空开销增长**  要比较两个算法的各方面性能有很多方法。

其中之一是各写一个程序，比较它们的运行情况。但是由于程序并不是算法的直接对应结果，无法避免一些和算法无关，只由代码产生的问题。而且需要写程序，这将花费比较大的精力，尤其是在算法复杂实现容易出错的时候。

另一个办法是在算法设计出来后直接针对算法进行分析，估计它的时间效率和空间开销。由于运行时间等因素和计算机运行速度有关，所以我们只关心在问题规模扩大时时空开销的增长情况。再次强调，我们很少进行程序分析，一般只进行算法分析。由算法描述写出高效程序属于程序设计方法的范畴，这不是我们讨论的重点。

**基本操作**  为了进行这样的估计，首先给这个估计问题建立合适的模型。用变量n表示输入问题的规模，而定义“基本操作”为一个运行时间不依赖于操作数的操作。

考虑两个正整数相加的操作 add。如果两个不大于100的正整数相加，那么运行时间总是常数；如果两个数的大小没有限制，那么操作依赖于两个数的位数。因此可以把情况一中的add看做基本操作，情况二中的add就不能看成基本操作（这时我们一般把每一位相加看成一个基本操作，它的运行时间是常数）。后面将看到，在不同的时候，把不同的操作看成基本操作。基本操作的选择反映了对问题的主要矛盾的认识。

可以用程序执行的基本操作数来衡量它的时间效率。例如下面的程序一

```text
fact = 1;
for (i = 1; i <= n; i++)
  fact *= i;

```

如果把一次乘法操作看成一个基本操作，那么程序共执行了 n个基本操作。注意，这里忽略了循环时改变变量i所花费的时间，而只关心和算法最有关系的基本操作。再看程序二：

```text
sum = 0;
for (i = 1; i <= n; i++)
  for (j = 1; j <= n; j++)
    sum += a[i][j];

```

它执行了 $n ^ 2
$ 个基本操作。

两个程序哪个快呢？不知道。因为不知道加法操作和乘法操作哪个快。

假设加法速度是乘法速度的10倍，那么哪个程序块快呢？您一定会说：不一定。当 $n \leqslant 10$是程序二快，而 $n > 10$时才是程序一快。这样说有道理。但是算法分析的结论会是：**程序一的渐进时间复杂度低，因此更优**。理由是：当规模扩大 10 倍时程序一的运行时间只扩大10倍，而程序二会扩大100倍。在这里，忽略了**常数因子**，因为我们只对**增长情况**感兴趣。下面不加说明地给出一些定义，请读者阅读相关书籍来了解这方面的详细内容。

## **复杂度分析的常用符号**

了解下面一个就行了。

大 O 表示法（big-Oh notation）表示的是运行时间的**上限**. O后面的括号中有一个函数，指明某个算法的耗时/耗空间与数据增长量之间的关系.

这里给出几种常见的表示法以及对应的含义：

- $O(1)$表示耗时/耗空间与输入数据大小无关，无论输入数据增大多少倍，耗时/耗空间都不变 比如哈希算法，不考虑哈希冲突的话一次计算后都可以找到目标值。

- $O(n)$代表数据量增大几倍，耗时也增大几倍。常见的比如数的遍历

- $O(n^2)$代表数据量增大n倍时，耗时增大n的平方倍。常见的比如冒泡排序双层for循环

- $O(log_n)$当数据增大n倍时，耗时增大logn倍（这里的log是以2为底的，比如，当数据增大256倍时，耗时只增大8倍，是比线性还要低的时间复杂度）。常见的比如二分查找、递归等

- $O(nlog_n
  )$同理，就是n乘以logn，当数据增大256倍时，耗时增大256*8=2048倍。这个复杂度高于线性低于平方。常见的比如归并排序。



# 1.2 基本算法

本节将介绍一些程序设计中最常见的算法，并通过例题来加深读者的理解。这些算法有：枚举、贪心、递归、分支、递推。本节的理论不强，题目也颇有趣味，大家可以仔细阅读。但是本节中有很多例子具有相当的难度，在第一次阅读时读者不必看懂所有内容。



## 1.2.1 枚举

如果手工都很容器算出来的东西，有理由相信写成程序以后也能很快得到结果。先来看一个简单的例子。

### 例题一 盒子里的气球

在一个长方体盒子里，有N（N≤6）个相异的点。在其中任何一个点上放一个很小的气球，那么这个气球会一直膨胀，直到接触到其它气球或者盒子的边界。必须等一个气球扩展完毕才能放置下一个气球。那么应该按照怎样的顺序在这N个点上放置气球，才能使放置完毕后所有气球占据的总体积最大呢？

注：球的体积公式 V = 4/3_pi _r_r_r，其中r为球的半径,pi=arccos(-1)

Input  
第一行一个整数N

第二行为长方体盒子一个顶点及其对角顶点的坐标，x y z x’ y’ z’

接下去N行，每行三个整数x1 y1 z1，表示盒子内N个点的坐标

以上所有的整数都在[-1000, 1000]内

Output  
长方体盒子剩余的最小空间（结果四舍五入输出）

SampleInput  
2  
0 0 0 10 10 10  
3 3 3  
7 7 7  
SampleOutput  
774

#### 分析

如果没有计算机，你可以算出答案吗？可以的。这道题目最多只有6个气球，因此只有 6! = 720 种放气球的顺序。没有每种顺序，手算出最后的剩余体积，比较后就知道哪种方案最优。虽然很花时间，但耐心点总是可以算出来的。在没有找到更好的方法之前就用这个方法写个程序，让计算机代替手算，用更快时间找到解。

